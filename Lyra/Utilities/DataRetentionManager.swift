//
//  DataRetentionManager.swift
//  Lyra
//
//  Phase 7.15: AI Ethics and Transparency
//  Data retention: clear policies, user-requested deletion, minimal storage, regular cleanup
//

import Foundation
import SwiftData

/// Data retention manager for managing AI data lifecycle and cleanup
class DataRetentionManager {
    static let shared = DataRetentionManager()

    private let defaults = UserDefaults.standard

    private init() {}

    // MARK: - Retention Policies

    /// Get data retention policy
    func getRetentionPolicy() -> DataRetentionPolicy {
        return DataRetentionPolicy(
            policyVersion: "1.0",
            lastUpdated: Date(),
            categories: [
                RetentionCategory(
                    name: "AI Suggestions",
                    dataType: "Chord progressions, lyrics, melodies generated by AI",
                    retentionPeriod: "30 days after last access",
                    automaticDeletion: true,
                    userControl: "Can delete immediately"
                ),
                RetentionCategory(
                    name: "Learning Data",
                    dataType: "User preferences, writing patterns, usage statistics",
                    retentionPeriod: "Indefinite (while feature is enabled)",
                    automaticDeletion: false,
                    userControl: "Can delete anytime"
                ),
                RetentionCategory(
                    name: "Practice History",
                    dataType: "Practice sessions, progress metrics, recommendations",
                    retentionPeriod: "90 days after last session",
                    automaticDeletion: true,
                    userControl: "Can delete anytime"
                ),
                RetentionCategory(
                    name: "Search History",
                    dataType: "Recent searches and query patterns",
                    retentionPeriod: "30 days",
                    automaticDeletion: true,
                    userControl: "Can delete anytime"
                ),
                RetentionCategory(
                    name: "Manual Overrides",
                    dataType: "Records of AI suggestions you modified",
                    retentionPeriod: "60 days",
                    automaticDeletion: true,
                    userControl: "Can delete anytime"
                ),
                RetentionCategory(
                    name: "Moderation History",
                    dataType: "Content moderation decisions and appeals",
                    retentionPeriod: "1 year",
                    automaticDeletion: true,
                    userControl: "View only (needed for appeals)"
                )
            ],
            minimumStorageCommitment: "We store only what's necessary for features to work",
            maximumStorageLimit: "~50MB total for all AI data per user"
        )
    }

    /// Get retention status for all data types
    func getRetentionStatus() -> [DataCategory: RetentionStatus] {
        var status: [DataCategory: RetentionStatus] = [:]

        for category in DataCategory.allCases {
            status[category] = RetentionStatus(
                category: category,
                currentSize: estimateDataSize(for: category),
                itemCount: estimateItemCount(for: category),
                oldestItem: getOldestItemDate(for: category),
                eligibleForCleanup: getEligibleForCleanupCount(for: category)
            )
        }

        return status
    }

    // MARK: - Automatic Cleanup

    /// Perform automatic cleanup based on retention policies
    func performAutomaticCleanup() {
        print("ðŸ§¹ Starting automatic data cleanup...")

        var deletedCounts: [String: Int] = [:]

        // Clean AI suggestions older than 30 days
        deletedCounts["AI Suggestions"] = cleanupAISuggestions(olderThan: 30)

        // Clean practice history older than 90 days
        deletedCounts["Practice History"] = cleanupPracticeHistory(olderThan: 90)

        // Clean search history older than 30 days
        deletedCounts["Search History"] = cleanupSearchHistory(olderThan: 30)

        // Clean manual overrides older than 60 days
        deletedCounts["Manual Overrides"] = cleanupManualOverrides(olderThan: 60)

        // Clean moderation history older than 1 year
        deletedCounts["Moderation History"] = cleanupModerationHistory(olderThan: 365)

        // Log cleanup results
        defaults.set(Date(), forKey: "lyra_last_cleanup_date")

        var totalDeleted = 0
        for (category, count) in deletedCounts {
            print("  âœ… \(category): \(count) items deleted")
            totalDeleted += count
        }

        print("ðŸ§¹ Cleanup complete: \(totalDeleted) total items removed")
    }

    /// Schedule automatic cleanup
    func scheduleAutomaticCleanup() {
        // Check if cleanup should run (once per week)
        if let lastCleanup = defaults.object(forKey: "lyra_last_cleanup_date") as? Date {
            let daysSinceCleanup = Calendar.current.dateComponents([.day], from: lastCleanup, to: Date()).day ?? 0

            if daysSinceCleanup < 7 {
                print("â³ Cleanup not needed yet (last run \(daysSinceCleanup) days ago)")
                return
            }
        }

        performAutomaticCleanup()
    }

    // MARK: - Manual Deletion

    /// Delete all AI data immediately
    func deleteAllAIData() {
        print("ðŸ—‘ï¸ Deleting all AI data...")

        // Delete via UserControlEngine (which has the deletion logic)
        UserControlEngine.shared.deleteAllAITrainingData()

        // Additional cleanup
        clearAllCaches()
        clearAllTempFiles()

        defaults.set(Date(), forKey: "lyra_manual_deletion_date")

        print("âœ… All AI data deleted")
    }

    /// Delete data for specific category
    func deleteDataForCategory(_ category: DataCategory) {
        print("ðŸ—‘ï¸ Deleting data for category: \(category.rawValue)")

        switch category {
        case .aiSuggestions:
            cleanupAISuggestions(olderThan: 0) // Delete all
        case .learningData:
            UserControlEngine.shared.deleteDataForFeature(.songwritingAssistant)
        case .practiceHistory:
            cleanupPracticeHistory(olderThan: 0)
        case .searchHistory:
            cleanupSearchHistory(olderThan: 0)
        case .recommendationHistory:
            UserControlEngine.shared.deleteDataForFeature(.songRecommendations)
        case .manualOverrides:
            cleanupManualOverrides(olderThan: 0)
        case .moderationHistory:
            cleanupModerationHistory(olderThan: 0)
        case .formattingPreferences:
            UserControlEngine.shared.deleteDataForFeature(.autoFormatting)
        }

        print("âœ… Data deleted for \(category.displayName)")
    }

    /// Export data retention report
    func exportRetentionReport() -> DataRetentionReport {
        let status = getRetentionStatus()
        let policy = getRetentionPolicy()

        var totalSize = 0
        var totalItems = 0
        for (_, retention) in status {
            totalSize += retention.currentSize
            totalItems += retention.itemCount
        }

        return DataRetentionReport(
            generatedAt: Date(),
            policy: policy,
            status: status,
            totalDataSize: totalSize,
            totalItemCount: totalItems,
            lastAutomaticCleanup: defaults.object(forKey: "lyra_last_cleanup_date") as? Date,
            lastManualDeletion: defaults.object(forKey: "lyra_manual_deletion_date") as? Date,
            nextScheduledCleanup: getNextScheduledCleanup()
        )
    }

    // MARK: - Data Minimization

    /// Verify minimal data storage compliance
    func verifyMinimalStorageCompliance() -> MinimalStorageCompliance {
        let status = getRetentionStatus()

        var oversizedCategories: [DataCategory] = []
        var recommendations: [String] = []

        // Check for oversized categories
        for (category, retention) in status {
            if retention.currentSize > category.maxRecommendedSize {
                oversizedCategories.append(category)
                recommendations.append("Consider cleaning up \(category.displayName) (currently \(retention.currentSize) bytes)")
            }
        }

        // Calculate total size
        let totalSize = status.values.reduce(0) { $0 + $1.currentSize }
        let maxAllowedSize = 50 * 1024 * 1024 // 50MB

        let compliant = totalSize < maxAllowedSize && oversizedCategories.isEmpty

        if totalSize > maxAllowedSize {
            recommendations.append("Total AI data exceeds 50MB limit. Run cleanup.")
        }

        if !compliant {
            recommendations.append("Enable automatic cleanup to maintain compliance")
        }

        return MinimalStorageCompliance(
            compliant: compliant,
            totalSize: totalSize,
            maxAllowedSize: maxAllowedSize,
            oversizedCategories: oversizedCategories,
            recommendations: recommendations
        )
    }

    // MARK: - User Rights

    /// Get user's data deletion rights summary
    func getUserDeletionRights() -> DataDeletionRights {
        return DataDeletionRights(
            rights: [
                "You can delete all AI data immediately at any time",
                "You can delete specific categories of data",
                "You can export your data before deletion",
                "Deletion is permanent and cannot be undone",
                "Some data may remain in device backups (iCloud)"
            ],
            howToDelete: [
                "Go to Settings â†’ AI & Privacy",
                "Select 'Delete AI Data'",
                "Choose 'Delete All' or specific categories",
                "Confirm deletion",
                "Data is removed immediately"
            ],
            whatHappensAfterDeletion: [
                "AI features lose personalization",
                "Recommendations reset to defaults",
                "Practice history is cleared",
                "Search history is removed",
                "You can start fresh anytime"
            ]
        )
    }

    // MARK: - Helper Methods

    private func cleanupAISuggestions(olderThan days: Int) -> Int {
        let cutoffDate = Calendar.current.date(byAdding: .day, value: -days, to: Date()) ?? Date()
        defaults.removeObject(forKey: "lyra_ai_suggestions_\(cutoffDate.timeIntervalSince1970)")
        return 0 // Would return actual count in production
    }

    private func cleanupPracticeHistory(olderThan days: Int) -> Int {
        // In production, would query SwiftData and delete old records
        return 0
    }

    private func cleanupSearchHistory(olderThan days: Int) -> Int {
        defaults.removeObject(forKey: "lyra_search_history")
        return 0
    }

    private func cleanupManualOverrides(olderThan days: Int) -> Int {
        let cutoffDate = Calendar.current.date(byAdding: .day, value: -days, to: Date()) ?? Date()

        if let data = defaults.data(forKey: "lyra_manual_overrides"),
           var overrides = try? JSONDecoder().decode([ManualOverride].self, from: data) {
            let originalCount = overrides.count
            overrides.removeAll { $0.timestamp < cutoffDate }

            if let encoded = try? JSONEncoder().encode(overrides) {
                defaults.set(encoded, forKey: "lyra_manual_overrides")
            }

            return originalCount - overrides.count
        }

        return 0
    }

    private func cleanupModerationHistory(olderThan days: Int) -> Int {
        // In production, would clean old moderation records
        return 0
    }

    private func clearAllCaches() {
        // Clear any cached AI data
        defaults.removeObject(forKey: "lyra_ai_cache")
    }

    private func clearAllTempFiles() {
        // Clear temporary AI files
        let tempDir = FileManager.default.temporaryDirectory
        try? FileManager.default.removeItem(at: tempDir.appendingPathComponent("lyra_ai_temp"))
    }

    private func estimateDataSize(for category: DataCategory) -> Int {
        // In production, would calculate actual size
        return 1024 * 100 // 100KB placeholder
    }

    private func estimateItemCount(for category: DataCategory) -> Int {
        // In production, would count actual items
        return 0
    }

    private func getOldestItemDate(for category: DataCategory) -> Date? {
        // In production, would query oldest item
        return nil
    }

    private func getEligibleForCleanupCount(for category: DataCategory) -> Int {
        // In production, would count items eligible for cleanup
        return 0
    }

    private func getNextScheduledCleanup() -> Date {
        if let lastCleanup = defaults.object(forKey: "lyra_last_cleanup_date") as? Date {
            return Calendar.current.date(byAdding: .day, value: 7, to: lastCleanup) ?? Date()
        }
        return Date()
    }
}

// MARK: - Data Models

/// Data retention policy
struct DataRetentionPolicy {
    let policyVersion: String
    let lastUpdated: Date
    let categories: [RetentionCategory]
    let minimumStorageCommitment: String
    let maximumStorageLimit: String
}

/// Retention category
struct RetentionCategory {
    let name: String
    let dataType: String
    let retentionPeriod: String
    let automaticDeletion: Bool
    let userControl: String
}

/// Data category
enum DataCategory: String, CaseIterable {
    case aiSuggestions = "ai_suggestions"
    case learningData = "learning_data"
    case practiceHistory = "practice_history"
    case searchHistory = "search_history"
    case recommendationHistory = "recommendation_history"
    case manualOverrides = "manual_overrides"
    case moderationHistory = "moderation_history"
    case formattingPreferences = "formatting_preferences"

    var displayName: String {
        switch self {
        case .aiSuggestions: return "AI Suggestions"
        case .learningData: return "Learning Data"
        case .practiceHistory: return "Practice History"
        case .searchHistory: return "Search History"
        case .recommendationHistory: return "Recommendation History"
        case .manualOverrides: return "Manual Overrides"
        case .moderationHistory: return "Moderation History"
        case .formattingPreferences: return "Formatting Preferences"
        }
    }

    var maxRecommendedSize: Int {
        switch self {
        case .aiSuggestions: return 5 * 1024 * 1024 // 5MB
        case .learningData: return 10 * 1024 * 1024 // 10MB
        case .practiceHistory: return 15 * 1024 * 1024 // 15MB
        case .searchHistory: return 1 * 1024 * 1024 // 1MB
        case .recommendationHistory: return 5 * 1024 * 1024 // 5MB
        case .manualOverrides: return 2 * 1024 * 1024 // 2MB
        case .moderationHistory: return 10 * 1024 * 1024 // 10MB
        case .formattingPreferences: return 1 * 1024 * 1024 // 1MB
        }
    }
}

/// Retention status
struct RetentionStatus {
    let category: DataCategory
    let currentSize: Int
    let itemCount: Int
    let oldestItem: Date?
    let eligibleForCleanup: Int
}

/// Data retention report
struct DataRetentionReport {
    let generatedAt: Date
    let policy: DataRetentionPolicy
    let status: [DataCategory: RetentionStatus]
    let totalDataSize: Int
    let totalItemCount: Int
    let lastAutomaticCleanup: Date?
    let lastManualDeletion: Date?
    let nextScheduledCleanup: Date
}

/// Minimal storage compliance
struct MinimalStorageCompliance {
    let compliant: Bool
    let totalSize: Int
    let maxAllowedSize: Int
    let oversizedCategories: [DataCategory]
    let recommendations: [String]
}

/// Data deletion rights
struct DataDeletionRights {
    let rights: [String]
    let howToDelete: [String]
    let whatHappensAfterDeletion: [String]
}
